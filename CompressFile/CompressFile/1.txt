#include"LZ77.h"


const USH MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const USH MAX_DIST = WSIZE - MIN_LOOKAHEAD;

//LZ77构造
LZ77::LZ77()
	:_pWin(new UCH[WSIZE * 2])
	, _ht(WSIZE)
{}
//LZ77的析构
LZ77::~LZ77()
{
	delete[] _pWin;
	_pWin = nullptr;
}

//LZ77的压缩算法
void LZ77::CompressFile(const string& strFilePath)
{
	//1，获取文件的大小-----如果源文件的大小小于3个字节（MIN_MATCH），则不进行处理
	FILE* fIn = fopen(strFilePath.c_str(), "rb");
	if (nullptr == fIn)
	{
		cout << "打开文件失败" << endl;
		return;
	}
	fseek(fIn, 0, SEEK_END);
	ULL fileSize = ftell(fIn);

	//如果源文件的大小小于MIN_MATCH,则不进行处理
	if (fileSize <= MIN_MATCH)
	{
		cout << "文件太小，不压缩" << endl;
		return;
	}
	//从源文件中读取一个缓冲区的数据到窗口中
	fseek(fIn, 0, SEEK_SET);
	size_t lookAhead = fread(_pWin, 1, 2 * WSIZE, fIn);

	USH start = 0;//先行缓冲区的第一个字节
	USH hashAddr = 0;

	//字符串的处理是把字节一个一个的传进去算的---设置起始的哈希地址
	for (USH i = 0; i < MIN_MATCH - 1; ++i)
	{
		_ht.HashFunc(hashAddr, _pWin[i]);
	}

	//压缩
	FILE* fOUT = fopen("2.lzp", "wb");//用来保存压缩数据
	assert(fOUT);

	USH matchHead = 0;//匹配链的头
	USH curMatchLength = 0;//当前的匹配长度
	USH curMatchDist = 0;//当前的匹配距离

	//与写标记相关的变量
	UCH chFlag = 0;
	UCH bitCount = 0;
	bool IsLen = false;
	//用来写标记的文件，前期先与压缩文件分开
	FILE* fOut = fopen("3.txt", "wb");
	assert(fOut);

	//lookAhead表示先行缓冲区中剩余的字数
	while (lookAhead)
	{

		//1,将当前的三个字符插入到哈希表中，并获取匹配头
		_ht.Insert(matchHead, _pWin[start + 2], start, hashAddr);

		curMatchLength = 0;
		curMatchDist = 0;

		//2,验证在查找缓冲区中是否找到匹配

		if (matchHead)//已经找到匹配链，顺着匹配链找到最长的匹配
		{
			//顺着匹配链找到最长匹配，得到长度距离对
			curMatchLength = LongestMatchChain(matchHead, curMatchDist,start);
		}
		
		//3,是否找到匹配（例如第一次就没有匹配）
		if (curMatchLength < MIN_MATCH)
		{
			//比最小的匹配长度3都要小，说明在查找缓冲区中没有找到匹配，把原字符写到源文件--将start位置的字符写入到压缩文件中
			fputc(_pWin[start], fOUT);
			WriteFlag(fOut, chFlag, bitCount, false);//写当前字符所对应的标记
			++start;
			lookAhead--;
		}
		else
		{
			//在查找缓冲区中找到匹配--将长度距离对写入到压缩文件中
			//先写长度再写距离是为了和Huffman相匹配
			UCH chLen = curMatchLength - 3;
			fputc(chLen, fOUT);//把长度写到压缩文件中
			fwrite(&curMatchDist, sizeof(curMatchDist), 1, fOUT);//将距离写入压缩文件

			WriteFlag(fOut, chFlag, bitCount, true);//写当前字符所对应的标记
			//更新先行缓冲区中剩余的个数
			lookAhead -= curMatchLength;

			//将已经匹配的字符串按照三个一组将其插入到哈希表中
			--curMatchLength;//当前字符串已经插入了，只需要处理后面的两个字符

			while (curMatchLength)//由于字符串已经压缩成长度距离对了，但我们并没有把字符串里面出首字符以外的，后面的字符3个一组的插入到哈希表中
			{
				start++;
				_ht.Insert(matchHead, _pWin[start+2], start, hashAddr);
				--curMatchLength;
			}

			start++;
		}
		//检测查找先行缓冲区中剩余的个数
		if (lookAhead <= MIN_LOOKAHEAD)
		{
			FillWindow(fIn,lookAhead,start);
		}
	}
	//标记位数如果不够8位
	if (bitCount > 0 && bitCount < 8)
	{
		chFlag <<= (8 - bitCount);
		fputc(chFlag, fOut);
	}
	fclose(fOut);//！！！现将标记的文件指针关闭，否则会因为标记信息在缓冲区中而没有写入文件里导致无法读取到内容

	MergeFile(fOUT,fileSize);
	fclose(fIn);
	fclose(fOUT);
}

//对窗口进行填充
void LZ77::FillWindow(FILE* fIn, size_t& _lookAhead,USH start)
{
	if (start > WSIZE)
	{
		//1,将右窗中的数据搬移到左床
		memcpy(_pWin, _pWin + WSIZE, WSIZE);
		memset(_pWin + WSIZE, 0, WSIZE);
		//2,更新哈希表
		_ht.updata();
		//3,向右窗中补充一个窗口的数据
		if (!feof(fIn))
		{
			_lookAhead = fread(_pWin + WSIZE, 1, WSIZE, fIn);
		}
	}
}



//将压缩数据与标记信息的文件进行合并
void LZ77::MergeFile(FILE* fOut, ULL fileSize)
{
	//1,读取标记信息文件中内容，然后将结果写入到压缩文件中
	FILE* fInF = fopen("3.txt", "rb");
	unsigned long flagSize = 0;
	UCH* pReadbuff = new UCH[1024];
	while (true)
	{
		size_t rdSize = fread(pReadbuff, 1, 1024, fInF);
		if (rdSize == 0)
		{
			break;
		}
		fwrite(pReadbuff, 1, rdSize, fOut);
		flagSize += rdSize;
	}
	//保存标记信息的字节数
	fwrite(&flagSize, sizeof(flagSize), 1, fOut);
	fwrite(&fileSize, sizeof(fileSize), 1, fOut);
	delete[] pReadbuff;
	fclose(fInF);
}

//最长匹配：在查找缓冲区中进行，可能会得到多个匹配，需要的是最长的匹配
//可能会碰到环-----设置一个最大的匹配次数    匹配是在MAX_DIST范围内进行的，太远则不匹配


USH LZ77::LongestMatchChain(USH matchHead, USH& MatchDist, USH start)
{
	UCH curMatchlen = 0;//每一次匹配过程中得到的长度
	USH maxMatchlen = 0;//最大的匹配长度
	UCH maxMatchCount = 255;//最大的匹配次数，用来解决环的问题
	USH curMatchStart = 0;//最长匹配串在滑动窗口的起始位置

	//在先行缓冲区中查找时，最远不能超过MAX_DIST，如果超过，就把匹配链中的字符舍弃掉
	USH limit = start > MAX_DIST ? start - MAX_DIST : 0;

	do
	{
		//匹配的范围---先行缓冲区中能匹配的起始范围
		UCH* pstart = _pWin + start;
		UCH* pend = pstart + MAX_MATCH;

		//查找缓冲区匹配串的起始
		UCH* pMatchStart = _pWin + matchHead;
		curMatchlen = 0;
		//可以进行匹配
		while (pstart < pend && *pstart == *pMatchStart)
		{
			curMatchlen++;
			pstart++;
			pMatchStart++;
		}

		//当一次匹配结束
		if (curMatchlen > maxMatchlen)
		{
			maxMatchlen = curMatchlen;
			curMatchStart = matchHead;
		}
	} while (_ht.GetNextHashAddr(matchHead)>limit && maxMatchCount--);

	MatchDist = start - curMatchStart;
	return maxMatchlen;
}

//chFlag用来标记原字符或长度距离对（两个取值：0或1）
//bitCount表示该字节已经有多少个比特位进行标记了
//isLen表示当前需要标记的是否是长度
void LZ77::WriteFlag(FILE* fOUT, UCH& chFlag, UCH& bitCount, bool isLen)
{
	chFlag <<= 1;
	if (isLen)
	{
		chFlag |= 1;
	}
	bitCount++;
	if (bitCount == 8)
	{
		//该字节已经写满，将其写入文件当中
		fputc(chFlag, fOUT);
		chFlag = 0;
		bitCount = 0;
	}
}



void LZ77::UNCompressFile(const string& strFilePath)
{
	//读取压缩数据的文件
	FILE* fInD = fopen(strFilePath.c_str(), "rb");
	if (nullptr == fInD)
	{
		cout << "压缩文件打开失败" << endl;
		return;
	}
	//操作标记数据的文件指针
	FILE* fInF = fopen(strFilePath.c_str(), "rb");
	if (nullptr == fInF)
	{
		cout << "压缩文件打开失败" << endl;
		return;
	}

	//获取源文件的大小
	ULL fileSize = 0;
	fseek(fInF, 0 - sizeof(fileSize), SEEK_END);
	fread(&fileSize, sizeof(fileSize), 1, fInF);

	//获取标记的大小
	size_t flagSize = 0;
	fseek(fInF, 0 - sizeof(fileSize) - sizeof(flagSize), SEEK_END);
	fread(&flagSize, sizeof(flagSize), 1, fInF);

	//将读取标记信息的文件指针移动到保存标记数据的起始位置
	fseek(fInF, 0 - sizeof(flagSize) - sizeof(fileSize) - flagSize, SEEK_END);

	//开始进行解压缩
	//写解压缩的数据
	FILE* fOut = fopen("4.txt", "wb");
	assert(fOut);

	//读取前文匹配串中的内容
	FILE* fR = fopen("4.txt", "rb");

	UCH bitCount = 0;
	UCH chFlag = 0;
	ULL encodeCount = 0;
	while (encodeCount<fileSize)
	{
		//读取标记
		if (0 == bitCount)
		{
			chFlag = fgetc(fInF);
			bitCount = 8;
		}

		if (chFlag & 0x80)
		{
			//是一个距离长度对
			USH matchLen = fgetc(fInD) + 3;
			USH matchDist = 0;
			fread(&matchDist, sizeof(matchDist), 1, fInD);

			fflush(fOut);//清空缓冲区，系统会将缓冲区中的数据写入文件中

			encodeCount += matchLen;//更新已经解码的字节数大小

			UCH ch;
			fseek(fR, 0 - matchDist, SEEK_END);

			while (matchLen)
			{
				ch = fgetc(fR);
				fputc(ch, fOut);
				matchLen--;
				fflush(fOut);
			}
		}
		else
		{
			//是一个原字符
			UCH ch = fgetc(fInD);
			fputc(ch, fOut);
			encodeCount += 1;
		}
		chFlag <<= 1;
		bitCount--;
	}
	fclose(fInD);
	fclose(fInF);
	fclose(fOut);
	fclose(fR);
}